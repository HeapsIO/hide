package hrt.animgraph;

typedef Edge = {target: Node, outputIndex: Int};

enum OutputType {
	TFloat;
	TAnimation;
}
typedef NodeOutputInfo = {
	name: String,
	type: OutputType,
}

typedef NodeInputInfo = { > NodeOutputInfo, ?def : Dynamic };

@:build(hrt.animgraph.Macros.build(false))
@:autoBuild(hrt.animgraph.Macros.build(true))
@:keep
@:keepSub
class Node
#if editor
implements hide.view.GraphInterface.IGraphNode
#end
{
	public function new() {
		inputEdges.resize(getInputs().length);
	};

	@:s public var x : Float;
	@:s public var y : Float;
	public var id : Int;
	public var inputEdges: Array<Edge> = [];
	var animGraph : AnimGraph;


	var tickedThisFrame = false;

	// Public overridable api

	/**
		Called by the animgraph once per frame. The @:inputs you declared in your
		class will be the one you need to use to update your @:outputs variables.
		This function should be "pure" in a sense that the state of the @:outputs
		should only depends on the state of your @:inputs, and not some other global
		state
	**/
	public function tick(dt: Float) : Void {

	}


	// Serialization api

	public function serializeToDynamic() : Dynamic {
		var data = {
			type: getNameId(),
		};

		copyToDynamic(data);

		// Serialize unconected node inputs values (that can be changed in the editor)
		for (i => inputInfo in getInputs()) {
			if (inputEdges[i] != null)
				continue;
			var inputValue = Reflect.getProperty(this, inputInfo.name);
			if (inputValue == inputInfo.def)
				continue;
			if (inputInfo.type == TFloat) {
				Reflect.setField(data, inputInfo.name, inputValue);
			}
		}

		return data;
	}


	static public function createFromDynamic(data: Dynamic) : Node {
		var type = registeredNodes.get(data.type);
		var inst = Std.downcast(std.Type.createInstance(type, []), Node);
		if (inst == null) {
			throw 'Could\'t not create node form type ${data.type}';
		}
		inst.copyFromDynamic(data);

		for (inputInfo in inst.getInputs()) {
			var val = Reflect.getProperty(data, inputInfo.name);
			if (val != null) {
				Reflect.setProperty(inst, inputInfo.name, val);
			}
		}

		return inst;
	}

	// Autogenerated macro interface

	// Do not override
	public function getInputs() : Array<NodeInputInfo> {
		return [];
	}

	// Do not override
	public function getOutputs() : Array<NodeOutputInfo> {
		return [];
	}

	#if editor

	public static var __nodeUID : Int = 0;

	public var editor : hide.view.GraphEditor;

	public function getAnimEditor() : hide.view.animgraph.AnimGraphEditor {
		return cast editor.editor;
	}


	static final SIZE_SMALL = 70;
	static final SIZE_DEFAULT = 150;
	static final SIZE_BIG = 200;

	public function getSize() : Int {
		return SIZE_DEFAULT;
	}

	// If not present in the child classes, will default to the class name
	// Auto overriden by build macro
	public function getDisplayName() : String {
		return "";
	}

	public function canCreateManually() : Bool {
		// Note : we can't actually create a "Node" in the add menu, but the child of Node should be
		// added to de addNodesMenu by default
		return true;
	}

	// IGraphNode interface

	public function getInfo() : hide.view.GraphInterface.GraphNodeInfo {
		return {
			name: getDisplayName(),
			inputs: [for (input in getInputs()) {
				name: input.name,
				color: getTypeColor(input.type),
				defaultParam: input.type != TFloat ? null : {
					get : () -> Std.string(Reflect.getProperty(this, input.name)),
					set : (v: String) -> {
						Reflect.setProperty(this, input.name, Std.parseFloat(v));
						getAnimEditor().refreshPreview();
					},
				},
			}],
			outputs: [for (output in getOutputs()) {
				name: getOutputNameOverride(output.name),
				color: getTypeColor(output.type),
			}],
			width: getSize(),
		}
	}

	public function getOutputNameOverride(name: String) : String {
		return name;
	}

	public function getPropertiesHTML(width : Float) : Array<hide.Element> {
		return [];
	}

	public function getPos(p: h2d.col.Point) : Void {
		p.x = x;
		p.y = y;
	}

	public function setPos(p: h2d.col.Point) : Void {
		x = p.x;
		y = p.y;
	}

	static function getTypeColor(type: OutputType) : Int {
		switch(type) {
			case TAnimation:
				return 0xDDDDDD;
			case TFloat:
				return 0x00ff73;
		}
	}

	static function areOutputsCompatible(a: OutputType, b: OutputType) : Bool {
		return a == b;
	}
	#end

	// Static helpers
	static public var registeredNodes = new Map<String, Class<Node>>();

	// Used by macros to auto-register nodes
	@:noCompletion
	static public function register(name: String, cl: Class<Node>) : Bool {
		registeredNodes.set(name, cl);
		return true;
	}
}