package hrt.animgraph;

typedef Edge = {target: Node, outputIndex: Int};

#if editor

enum OutputType {
	TFloat;
	TAnimation;
}

typedef NodeOutputInfo = {
	name: String,
	type: OutputType,
}

typedef NodeInputInfo = { > NodeOutputInfo, ?def : Dynamic };

#end
@:build(hrt.animgraph.Macros.build(false))
@:autoBuild(hrt.animgraph.Macros.build(true))
@:keep
@:keepSub
class Node
#if editor
implements hide.view.GraphInterface.IGraphNode
#end
{
	@:s public var x : Float;
	@:s public var y : Float;
	public var inputEdges: Array<Edge> = [];

	var tickedThisFrame = false;

	// Public overridable api

	/**
		Called by the animgraph once per frame. The @:inputs you declared in your
		class will be the one you need to use to update your @:outputs variables.
		This function should be "pure" in a sense that the state of the @:outputs
		should only depends on the state of your @:inputs, and not some other global
		state
	**/
	public function tick(dt: Float) : Void {

	}


	// Serialization api

	public function serializeToDynamic() : Dynamic {
		var data = {
			type: getNameId(),
		};

		copyToDynamic(data);
		return data;
	}

	static public function createFromDynamic(data: Dynamic) : Node {
		var type = registeredNodes.get(data.type);
		var inst = Std.downcast(std.Type.createInstance(type, []), Node);
		if (inst == null) {
			throw 'Could\'t not create node form type ${data.type}';
		}
		inst.copyFromDynamic(data);
		return inst;
	}

	#if editor

	public var id : Int;
	public static var __nodeUID : Int = 0;

	public var editor : hide.view.GraphEditor;


	static final SIZE_SMALL = 70;
	static final SIZE_DEFAULT = 150;
	static final SIZE_BIG = 200;

	public function getSize() : Int {
		return SIZE_DEFAULT;
	}

	// Autogenerated macro interface

	// Do not override
	public function getInputs() : Array<NodeInputInfo> {
		return [];
	}

	// Do not override
	public function getOutputs() : Array<NodeOutputInfo> {
		return [];
	}

	// If not present in the child classes, will default to the class name
	// Auto overriden by build macro
	public function getDisplayName() : String {
		return "";
	}

	public function canCreateManually() : Bool {
		// Note : we can't actually create a "Node" in the add menu, but the child of Node should be
		// added to de addNodesMenu by default
		return true;
	}

	// IGraphNode interface

	public function getInfo() : hide.view.GraphInterface.GraphNodeInfo {
		return {
			name: getDisplayName(),
			inputs: [for (input in getInputs()) {
				name: input.name,
				color: getTypeColor(input.type),
			}],
			outputs: [for (output in getOutputs()) {
				name: output.name,
				color: getTypeColor(output.type),
			}],
			width: getSize(),
		}
	}

	public function getPropertiesHTML(width : Float) : Array<hide.Element> {
		return [];
	}

	public function getPos(p: h2d.col.Point) : Void {
		p.x = x;
		p.y = y;
	}

	public function setPos(p: h2d.col.Point) : Void {
		x = p.x;
		y = p.y;
	}

	// Static helpers
	static public var registeredNodes = new Map<String, Class<Node>>();

	// Used by macros to auto-register nodes
	@:noCompletion
	static public function register(name: String, cl: Class<Node>) : Bool {
		registeredNodes.set(name, cl);
		return true;
	}

	static function getTypeColor(type: OutputType) : Int {
		switch(type) {
			case TAnimation:
				return 0xDDDDDD;
			case TFloat:
				return 0x00ff73;
		}
	}

	static function areOutputsCompatible(a: OutputType, b: OutputType) : Bool {
		return a == b;
	}
	#end
}